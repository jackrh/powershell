;;; powershell-completion --- completion for powershell mode -*- lexical-binding: t -*-

;; Author: Noah Peart <noah.v.peart@gmail.com>
;; URL: https://github.com/nverno/powershell
;; Package-Requires: 
;; Copyright (C) 2016, Noah Peart, all rights reserved.
;; Created: 2 October 2016

;; This file is not part of GNU Emacs.
;;
;; This program is free software; you can redistribute it and/or
;; modify it under the terms of the GNU General Public License as
;; published by the Free Software Foundation; either version 3, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;; General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program; see the file COPYING.  If not, write to
;; the Free Software Foundation, Inc., 51 Franklin Street, Fifth
;; Floor, Boston, MA 02110-1301, USA.

;;; Commentary:

;; Completion functions for powershell-mode.
;;
;; Uses hash tables/obarray generated by build scripts to provide completions.
;;

;;; Code:

(eval-when-compile
  (require 'subr-x))
(require 'company)

(defun powershell-function-name ()
  "Find function name in current context."
  (let ((ppss (syntax-ppss))
        (start (or (cdr (bounds-of-thing-at-point 'symbol)) (point))))
    (when (not (nth 4 ppss))
      (save-excursion 
        (skip-chars-backward "^.=><|)}%\[\]" (line-beginning-position))
        (cond
         ((eq (char-before) ?%)
          `(nil . "Foreach-Object"))
         ((eq (char-before) ?\])
          (skip-chars-backward "^\[" (line-beginning-position))
          (when (re-search-forward "\\([-.A-Za-z]+\\)]::\\([-A-Za-z]+\\)" start t)
            (cons (match-string-no-properties 1) (match-string-no-properties 2))))
         (t
          (when (re-search-forward "\\s-*\\([-A-Za-z]+\\)" start t)
            (cons nil (match-string-no-properties 1)))))))))


;; Using `powershell-eldoc-obarray'
(defun powershell-capf-obarray ()
  "Powershell completion at point function.  Uses `powershell-eldoc-obarray' to complete 
function arguments."
  (when (bound-and-true-p powershell-eldoc-obarray)
    (when-let ((bnds (bounds-of-thing-at-point 'symbol)))
      (cond
       ((eq (char-after (car bnds)) ?-)
        (when-let ((func (powershell-function-name)))
          (and (not (car func))
               (let ((pars (eval (intern-soft (downcase (cdr func))
                                              powershell-eldoc-obarray))))
                 (and pars
                      (list (1+ (car bnds)) (cdr bnds) pars))))))
       ;; $vars
       ))))

;; ------------------------------------------------------------
;;* Use hashed values

(defun powershell-hash-test (s1 s2)
  (eq t (compare-strings s1 nil nil s2 nil nil t)))

(defun powershell-case-fold-hash (s)
  (sxhash (upcase s)))

(define-hash-table-test 'powershell-hash 'powershell-hash-test
  'powershell-case-fold-hash)

(defvar posh-variables (make-hash-table :test 'powershell-hash))
(defvar posh-functions (make-hash-table :test 'powershell-hash))
(defvar posh-env (make-hash-table :test 'powershell-hash))

;; lookup alias or function
(defun powershell-lookup-function (func)
  (when-let ((val (gethash func posh-functions)))
    (if (assoc 'alias val)
        (gethash (cdr (assoc 'alias val)) posh-functions)
      val)))

;; ------------------------------------------------------------
;;* Company

(defun powershell-capf--var-docsig (obj)
  (cdr (assoc 'value (gethash obj posh-variables))))

(defun powershell-capf--fn-docsig (obj)
  (cdr (assoc 'synopsis (powershell-lookup-function obj))))

(defun powershell-capf--doc-buffer (obj)
  (company-doc-buffer
   (replace-regexp-in-string
    "\n\n+" "\n\n"
    (shell-command-to-string
     (format "powershell -c \"Get-Help %s | %%{$_.Description}\"" obj)))))

(defun powershell-capf--var-annotation (obj)
  (or (cdr (assoc 'annot (gethash obj posh-variables)))))

(defun powershell-capf--fn-annotation (obj)
  (or (cdr (assoc 'type (gethash obj posh-functions)))))

(defun powershell-capf ()
  (let ((bnds (bounds-of-thing-at-point 'symbol)))
    (cond
     ;; directly following ':', possibly drive: or [..]::
     ((and (not bnds)
           (eq (char-before (point)) ?:)
           (looking-back "env:" 4))
      (list (point) (point) posh-env))
     ;; function / cmdlet parameter
     ((eq (char-after (car bnds)) ?-)
      (when-let ((func (powershell-function-name)))
        (and (not (car func))
             (let ((pars (cdr (assoc 'params (powershell-lookup-function (cdr func))))))
               (and pars
                    (list (1+ (car bnds)) (cdr bnds) pars
                          :company-require-match nil))))))
     ;; $ variable, before ':'
     ((eq (char-after (car bnds)) ?$)
      (list (1+ (car bnds)) (cdr bnds) posh-variables
            :company-docsig #'powershell-capf--var-docsig
            :annotation-function #'powershell-capf--var-annotation
            :company-require-match nil))
     ;; either $drive:| or possible function
     ((when-let ((func (powershell-function-name)))
        (and (not (car func))
             ;; env:
             (or (and (compare-strings "env" nil nil (cdr func) nil nil t)
                      (list (car bnds) (cdr bnds) posh-env
                            :annotation-function #'powershell-capf--var-annotation
                            :company-docsig #'powershell-capf--var-docsig
                            :company-require-match nil))
                 ;; try function/cmdlet
                 (list (car bnds) (cdr bnds) posh-functions
                       :company-docsig #'powershell-capf--fn-docsig
                       :company-doc-buffer #'powershell-capf--doc-buffer
                       :annotation-function #'powershell-capf--fn-annotation
                       :company-require-match nil))))))))

(provide 'powershell-completion)

;;; powershell-completion.el ends here
